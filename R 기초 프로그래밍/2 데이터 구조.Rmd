---
title: "2 데이터 구조"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 2.1 벡터

벡터(Vector)는 하나 이상의 데이터를 저장할 수 있는 1차원 저장 구조(1차원 배열)

```{r}
students_age <- c(11, 12, 13, 20, 15, 21)
students_age
class(students_age)   # 데이터 타입 확인
length(students_age)  # 벡터의 길이 확인
str(students_age)     # 데이터 타입, 길이 등 전체 구조 확인
```

### 2.1.1 일부 데이터만 접근

인덱싱과 슬라이싱을 이용하여 일부 데이터만 접근할 수 있다.

```{r}
# 벡터 인덱싱(R의 인덱스는 1부터 시작)
students_age[1]  # 1번 인덱스의 데이터 추출하기
students_age[3]  # 3번 인덱스의 데이터 추출하기
students_age[-1]  # 1번 인덱스의 데이터만 제외하고 추출하기기

# 벡터 슬라이싱
students_age[1:3]  # 1번부터 3번 인덱스까지의 데이터 추출하기
students_age[4:6]  # 4번부터 6번 인덱스까지의 데이터 추출하기
```

### 2.1.2 벡터에 데이터 추가, 갱신

인덱스를 이용해서 벡터에 데이터를 갱신하거나 추가할 수 있다.

```{r}
score <- c(1,2,3)
score[1] <- 10
score[4] <- 4
score
```

### 2.1.3 벡터의 데이터 타입

벡터는 하나의 원시 데이터 타입으로 저장되므로, 다양한 데이터 타입을 섞어 저장하면 하나의 타입으로 자동 형변환된다.

```{r}
code <- c(1,12,"30")  # 문자(character) 데이터 타입으로 모두 변환됨
class(code) 
str(code)
```

```{r}
code <- c(1,12, TRUE, FALSE)  # 숫자(numeric) 데이터 타입으로 모두 변환됨
class(code) 
str(code)                     # TRUE는 1, FALSE는 0의 숫자로 변환됨
```

### 2.1.3 벡터 데이터 생성

```{r}
data <- c(1:10)  # 1부터 10까지 1씩 증가시켜 생성하기
data

data1 <- seq(1,10) # 1부터 10까지 1씩 증가시켜 생성하기
data1

data2 <- seq(1, 10, by=2) # 1부터 10까지 2씩 증가시켜 생성하기
data2

data3 <- rep(1, times=5)  #1을 다섯 번 반복 생성하기
data3

data4 <- rep(1:3, each=3)  #1부터 3을 각각 세 번씩 반복 생성하기
data4

data5 <- rep(1:3, times=3)
data5
```

---

## 2.2 행렬

행렬(Matrix)는 표 형태와 같은 2차원 데이터 저장 구조를 가진다. 행렬은 벡터와 마찬가지로 모두 같은 데이터 타입이어야 한다.

```{r}
var1 <- c(1, 2, 3, 4, 5, 6)

# var1을 이용해서 2행 3열 행렬을 생성. 기본적으로 열 우선으로 값이 채워짐
x1 <- matrix(var1, nrow=2, ncol=3)
x1

# var1을 이용해서 2열 행렬을 생성. 행의 개수는 자동 계산됨
x2 <- matrix(var1, ncol=2)
x2
```

### 2.2.1 일부 데이터만 접근

```{r}
x1[1,]  # x1의 1행, 모든 열
x1[,1]  # x1의 모든 행, 1열
x1[2,2]  #x1의 2행, 2열
```

dimnames()로 행렬의 행 이름, 열 이름을 부여할 수 있으며, 행 이름과 열 이름으로도 데이터 접근이 가능하다.

```{r}
var1 <- c(1, 2, 3, 4, 5, 6)
x2 <- matrix(var1, ncol=2)
dimnames(x2) <- list(c("r1", "r2", "r3"), c("c1", "c2"))   # x2행렬에 행 이름과 열 이름 부여
x2

x2[, "c1"]      # x2의 모든 행, c1열

x2["r1", ]      # x2의 r1행, 모든 열

x2["r1", "c1"]  # x2의 r1행, c1열
```

### 2.2.2 행렬에 데이터 추가

```{r}
x1 <- matrix(c(1, 2, 3, 4, 5, 6), nrow=2, ncol=3)
x1
x1 <- rbind(x1, c(10, 10, 10))  # 행 추가
x1 <- cbind(x1, c(20, 20, 20))  # 열 추가
x1
```

---

## 2.3 데이터프레임

데이터프레임(Dataframe)은 행렬처럼 행과 열을 가진 2차원 구조다. **벡터, 행렬과 다른 점은 각 열이 서로 다른 데이터 형식을 가질 수 있다**는 것이다(단, 각 벡터의 길이가 동일해야 한다). 

```{r}
no <- c(10,20,30,40,50,60,70)
age <- c(18,15,13,12,10,9,7)
gender <- c("M", "M", "M", "M", "M", "F", "M")

# 데이터프레임 생성
students <- data.frame(no, age, gender)
students

# 열의 이름과 행의 이름 확인
colnames(students)  # 열 이름 확인
rownames(students)  # 행 이름 확인

colnames(students)  <- c("no", "나이", "성별")               # 열 이름 수정
rownames(students)  <- c('A', 'B', 'C', 'D', 'E', 'F', 'G')  # 행 이름 수정

students
```

### 2.3.1 일부 데이터만 접근

```{r}
no <- c(10,20,30,40,50,60,70)
age <- c(18,15,13,12,10,9,7)
gender <- c("M", "M", "M", "M", "M", "F", "M")
students <- data.frame(no, age, gender)
rownames(students)  <- c('A', 'B', 'C', 'D', 'E', 'F', 'G')

# 열 이름으로 특정 열에 접근하기
# 데이터프레임의 변수이름$열이름으로 특정 열에 접근하기
students$no
students$age

# 대괄호 안에 열이름으로 특정 열에 접근하기
# 대괄호 안에 콤마(,)를 쓴 후 열이름을 쓴다. 열이름은 " " 또는 ' '로 감쌈
students[,"no"]
students[,"age"]

# 열 인덱스로 특정 열에 접근하기
students[,1]  # 첫번째 열 데이터가 모두 출력됨
students[,2]  # 두번째 열 데이터가 모두 출력됨

# 행 이름으로 특정 행만 접근하기
students["A", ]  # A행 데이터가 출력된다. 행이름은 " " 또는 ' '로 감쌈
                 # 행 이름 뒤에 콤마(,)를 반드시 써야함

# 행 인덱스로 특정 행만 접근하기
students[2,]  # 두번째 행 데이터가 출력
              # 행 인덱스 뒤에 콤마(,)를 반드시 써야함

# 행 인덱스, 열 인덱스 또는 행 이름, 열 이름으로 데이터에 접근하기
students[3,1]        # 변수이름[행인덱스, 열인덱스]로 작성
students["A", "no"]  # 변수이름["행이름", "열이름"]으로 작성
```

### 2.3.2 데이터프레임의 데이터 타입

벡터의 경우 class()로 데이터 타입을 확인하면 벡터 내에 저장된 데이터 타입이 출력되지만 그 외의 데이터 구조는 데이터 구조 자체의 타입이 출력된다. 데이터 구조도 하나의 데이터 타입이다.

```{r}
no <- c(10,20,30,40,50,60,70)
age <- c(18,15,13,12,10,9,7)
gender <- c("M", "M", "M", "M", "M", "F", "M")
students <- data.frame(no, age, gender)

class(students)

# 특정 열의 데이터 타입 확인
class(students$no)
class(students$gender)
```

데이터프레임 생성 시 문자타입을 팩터타입으로 생성하고 싶으면 stringsAsFactors = TRUE 옵션을 사용하면 된다.

```{r}
no <- c(10,20,30,40,50,60,70)
age <- c(18,15,13,12,10,9,7)
gender <- c("M", "M", "M", "M", "M", "F", "M")

students <- data.frame(no, age, gender, stringsAsFactors = TRUE)

class(students$gender)
```

> 데이터 타입을 확인하기 위해 class(), typeof(), mode() /등의 함수를 사용할 수 있다. 세 함수는 각각 다른 값을 가질 수도 아닐 수도 있다. class()는 객체지향 관덤에서 상속받은 클래스 이름을 반환하고, typeof()는 내부에 저장되는 형식인 원시 데이터 타입을 반환한다. mode()는 typeof()ㅣ보다 더 넓은 의미의 데이터 타입이다. 예를 들어 typeof()가 double이나 interger로 반환하는 타입을 mode()는 모두 numeric으로 반환한다.

```{r}
a <- 10
class(a)
mode(a)
typeof(a)
```

### 2.3.3 데이터프레임의 구조

```{r}
no <- c(10,20,30,40,50,60,70)
age <- c(18,15,13,12,10,9,7)
gender <- c("M", "M", "M", "M", "M", "F", "M")
students <- data.frame(no, age, gender)

# str()로 대략적 구조 확인
str(students)

# dim()으로 차원 정보 확인
dim(students)

# head()와 tail()로 일부 데이터만 추출 (빅데이터의 경우 유용)
head(students)   # 앞의 6행만 추출
tail(students)   # 뒤의 6행만 추출
```

### 2.3.4 데이터프레임 데이터 추가

```{r}
no <- c(10,20,30,40,50,60,70)
age <- c(18,15,13,12,10,9,7)
gender <- c("M", "M", "M", "M", "M", "F", "M")
students <- data.frame(no, age, gender)
rownames(students)  <- c('A', 'B', 'C', 'D', 'E', 'F', 'G')

# 열 데이터 추가
students$name <- c("이용", "준희", "이훈", "서희", "승희", "하정", "하준")  # 열 추가
students

# 행 데이터 추가
students["H",] <- c(80,10,'M','홍길동')  # 헹 추가
tail(students)
```

---

## 2.4 배열

배열(Array)는 다차원 데이터 저장 구조다. 벡터나 행렬처럼 하나의 원시 데이터 타입으로 저장된다.

```{r}
var1 <- c(1:12)  # 벡터 생성하기

arr1 <- array(var1, dim=c(2,2,3))    # 3차원 배열 생성
arr1

arr2 <- array(var1, dim=c(6,2))      # 2차원 배열 생성
arr2

arr3 <- array(var1, dim=c(2,2,3,1))  # 4차원 배열 생성
arr3

arr4 <- array(var1, dim=c(2,2,2,2))
arr4
```

---

## 2.5 리스트

리스트(List)는 다차원 데이터 저장 구조다. 배열과 다른 점은 키와 값 쌍으로 저장되며 값에 해당하는 데이터가 벡터, 행렬, 배열, 리스트 등 어떠한 데이터 구조의 데이터도 가능하다는 점이다.

```{r}
v_data <- c("02-111-2222", "01022223333")            # 벡터
m_data <- matrix(c(21:26), nrow=2)                   # 행렬
a_data <- array(c(31:36), dim=c(2,2,2))              # 배열
d_data <- data.frame(address = c("seoul", "busan"),  # 데이터프레임
                     name = c("Lee", "Kim"), stringsAsFactors = F)

# list(키1=값, 키2=값, ...,)와 같이 키와 값 쌍으로 리스트 생성
list_data <- list(name="홍길동",
                  tel=v_data,
                  score1=m_data,
                  score2=a_data,
                  friends=d_data)
list_data

# 리스트이름$키
list_data$name  # list_data에서 name키와 쌍을 이루는 데이터

list_data$tel   # list_data에서 tel키와 쌍을 이루는 데이터

# 리스트이름[숫자]
list_data[1]  # list_data에서 첫 번째 서브 리스트
```

